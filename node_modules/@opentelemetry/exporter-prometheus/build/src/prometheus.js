"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("@opentelemetry/base");
const core_1 = require("@opentelemetry/core");
const metrics_1 = require("@opentelemetry/metrics");
const http_1 = require("http");
const prom_client_1 = require("prom-client");
const url = require("url");
class PrometheusExporter {
    // This will be required when histogram is implemented. Leaving here so it is not forgotten
    // Histogram cannot have a label named 'le'
    // private static readonly RESERVED_HISTOGRAM_LABEL = 'le';
    /**
     * Constructor
     * @param config Exporter configuration
     * @param callback Callback to be called after a server was started
     */
    constructor(config = {}, callback) {
        this._registry = new prom_client_1.Registry();
        this._invalidCharacterRegex = /[^a-z0-9_]/gi;
        /**
         * Request handler used by http library to respond to incoming requests
         * for the current state of metrics by the Prometheus backend.
         *
         * @param request Incoming HTTP request to export server
         * @param response HTTP response object used to respond to request
         */
        this._requestHandler = (request, response) => {
            if (url.parse(request.url).pathname === this._endpoint) {
                this._exportMetrics(response);
            }
            else {
                this._notFound(response);
            }
        };
        /**
         * Responds to incoming message with current state of all metrics.
         */
        this._exportMetrics = (response) => {
            response.statusCode = 200;
            response.setHeader('content-type', this._registry.contentType);
            response.end(this._registry.metrics() || '# no registered metrics');
        };
        /**
         * Responds with 404 status code to all requests that do not match the configured endpoint.
         */
        this._notFound = (response) => {
            response.statusCode = 404;
            response.end();
        };
        this._logger = config.logger || new core_1.NoopLogger();
        this._port = config.port || PrometheusExporter.DEFAULT_OPTIONS.port;
        this._prefix = config.prefix || PrometheusExporter.DEFAULT_OPTIONS.prefix;
        this._server = http_1.createServer(this._requestHandler);
        this._endpoint = (config.endpoint || PrometheusExporter.DEFAULT_OPTIONS.endpoint).replace(/^([^/])/, '/$1');
        if (config.startServer || PrometheusExporter.DEFAULT_OPTIONS.startServer) {
            this.startServer(callback);
        }
        else if (callback) {
            callback();
        }
    }
    /**
     * Saves the current values of all exported {@link ReadableMetric}s so that they can be pulled
     * by the Prometheus backend.
     *
     * @todo reach into metrics to pull metric values on endpoint
     * In its current state, the exporter saves the current values of all metrics when export
     * is called and returns them when the export endpoint is called. In the future, this should
     * be a no-op and the exporter should reach into the metrics when the export endpoint is
     * called. As there is currently no interface to do this, this is our only option.
     *
     * @param readableMetrics Metrics to be sent to the prometheus backend
     * @param cb result callback to be called on finish
     */
    export(readableMetrics, cb) {
        if (!this._server) {
            // It is conceivable that the _server may not be started as it is an async startup
            // However unlikely, if this happens the caller may retry the export
            cb(base_1.ExportResult.FAILED_RETRYABLE);
            return;
        }
        this._logger.debug('Prometheus exporter export');
        for (const readableMetric of readableMetrics) {
            this._updateMetric(readableMetric);
        }
        cb(base_1.ExportResult.SUCCESS);
    }
    /**
     * Shuts down the export server and clears the registry
     *
     * @param cb called when server is stopped
     */
    shutdown(cb) {
        this._registry.clear();
        this.stopServer(cb);
    }
    /**
     * Updates the value of a single metric in the registry
     *
     * @param readableMetric Metric value to be saved
     */
    _updateMetric(readableMetric) {
        const metric = this._registerMetric(readableMetric);
        if (!metric)
            return;
        const labelKeys = readableMetric.descriptor.labelKeys;
        if (metric instanceof prom_client_1.Counter) {
            for (const ts of readableMetric.timeseries) {
                // Prometheus counter saves internal state and increments by given value.
                // ReadableMetric value is the current state, not the delta to be incremented by.
                // Currently, _registerMetric creates a new counter every time the value changes,
                // so the increment here behaves as a set value (increment from 0)
                metric.inc(this._getLabelValues(labelKeys, ts.labelValues), ts.points[0].value);
            }
        }
        if (metric instanceof prom_client_1.Gauge) {
            for (const ts of readableMetric.timeseries) {
                metric.set(this._getLabelValues(labelKeys, ts.labelValues), ts.points[0].value);
            }
        }
        // TODO: only counter and gauge are implemented in metrics so far
    }
    _getLabelValues(keys, values) {
        const labelValues = {};
        for (let i = 0; i < keys.length; i++) {
            if (values[i].value !== null) {
                labelValues[keys[i]] = values[i].value;
            }
        }
        return labelValues;
    }
    _registerMetric(readableMetric) {
        const metricName = this._getPrometheusMetricName(readableMetric.descriptor);
        const metric = this._registry.getSingleMetric(metricName);
        /**
         * Prometheus library does aggregation, which means its inc method must be called with
         * the value to be incremented by. It does not have a set method. As our ReadableMetric
         * contains the current value, not the value to be incremented by, we destroy and
         * recreate counters when they are updated.
         *
         * This works because counters are identified by their name and no other internal ID
         * https://prometheus.io/docs/instrumenting/exposition_formats/
         */
        if (metric instanceof prom_client_1.Counter) {
            this._registry.removeSingleMetric(metricName);
        }
        else if (metric)
            return metric;
        return this._newMetric(readableMetric, metricName);
    }
    _newMetric(readableMetric, name) {
        const metricObject = {
            name,
            // prom-client throws with empty description which is our default
            help: readableMetric.descriptor.description || 'description missing',
            labelNames: readableMetric.descriptor.labelKeys,
            // list of registries to register the newly created metric
            registers: [this._registry],
        };
        switch (readableMetric.descriptor.type) {
            case metrics_1.MetricDescriptorType.COUNTER_DOUBLE:
            case metrics_1.MetricDescriptorType.COUNTER_INT64:
                // there is no such thing as a non-monotonic counter in prometheus
                return readableMetric.descriptor.monotonic
                    ? new prom_client_1.Counter(metricObject)
                    : new prom_client_1.Gauge(metricObject);
            case metrics_1.MetricDescriptorType.GAUGE_DOUBLE:
            case metrics_1.MetricDescriptorType.GAUGE_INT64:
                return new prom_client_1.Gauge(metricObject);
            default:
                // Other metric types are currently unimplemented
                return undefined;
        }
    }
    _getPrometheusMetricName(descriptor) {
        return this._sanitizePrometheusMetricName(this._prefix ? `${this._prefix}_${descriptor.name}` : descriptor.name);
    }
    /**
     * Ensures metric names are valid Prometheus metric names by removing
     * characters allowed by OpenTelemetry but disallowed by Prometheus.
     *
     * https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels
     *
     * 1. Names must match `[a-zA-Z_:][a-zA-Z0-9_:]*`
     *
     * 2. Colons are reserved for user defined recording rules.
     * They should not be used by exporters or direct instrumentation.
     *
     * OpenTelemetry metric names are already validated in the Meter when they are created,
     * and they match the format `[a-zA-Z][a-zA-Z0-9_.\-]*` which is very close to a valid
     * prometheus metric name, so we only need to strip characters valid in OpenTelemetry
     * but not valid in prometheus and replace them with '_'.
     *
     * @param name name to be sanitized
     */
    _sanitizePrometheusMetricName(name) {
        return name.replace(this._invalidCharacterRegex, '_'); // replace all invalid characters with '_'
    }
    /**
     * Stops the Prometheus export server
     * @param callback A callback that will be executed once the server is stopped
     */
    stopServer(callback) {
        if (!this._server) {
            this._logger.debug(`Prometheus stopServer() was called but server was never started.`);
            if (callback) {
                callback();
            }
        }
        else {
            this._server.close(() => {
                this._logger.debug(`Prometheus exporter was stopped`);
                if (callback) {
                    callback();
                }
            });
        }
    }
    /**
     * Starts the Prometheus export server
     *
     * @param callback called once the server is ready
     */
    startServer(callback) {
        this._server.listen(this._port, () => {
            this._logger.debug(`Prometheus exporter started on port ${this._port} at endpoint ${this._endpoint}`);
            if (callback) {
                callback();
            }
        });
    }
}
exports.PrometheusExporter = PrometheusExporter;
PrometheusExporter.DEFAULT_OPTIONS = {
    port: 9464,
    startServer: false,
    endpoint: '/metrics',
    prefix: '',
};
//# sourceMappingURL=prometheus.js.map