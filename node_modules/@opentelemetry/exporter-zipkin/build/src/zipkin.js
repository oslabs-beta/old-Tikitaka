"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const url = require("url");
const core_1 = require("@opentelemetry/core");
const base_1 = require("@opentelemetry/base");
const transform_1 = require("./transform");
const utils_1 = require("./utils");
/**
 * Zipkin Exporter
 */
class ZipkinExporter {
    constructor(config) {
        const urlStr = config.url || ZipkinExporter.DEFAULT_URL;
        const urlOpts = url.parse(urlStr);
        this._forceFlush = config.forceFlush || true;
        this._logger = config.logger || new core_1.NoopLogger();
        this._reqOpts = Object.assign({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                [utils_1.OT_REQUEST_HEADER]: 1,
            },
        }, urlOpts);
        this._serviceName = config.serviceName;
        this._statusCodeTagName = config.statusCodeTagName || transform_1.statusCodeTagName;
        this._statusDescriptionTagName =
            config.statusDescriptionTagName || transform_1.statusDescriptionTagName;
        this._isShutdown = false;
    }
    /**
     * Export spans.
     */
    export(spans, resultCallback) {
        this._logger.debug('Zipkin exporter export');
        if (this._isShutdown) {
            setTimeout(() => resultCallback(base_1.ExportResult.FAILED_NOT_RETRYABLE));
            return;
        }
        return this._sendSpans(spans, resultCallback);
    }
    /**
     * Shutdown exporter. Noop operation in this exporter.
     */
    shutdown() {
        this._logger.debug('Zipkin exporter shutdown');
        if (this._isShutdown) {
            return;
        }
        this._isShutdown = true;
        // Make an optimistic flush.
        if (this._forceFlush) {
            // @todo get spans from span processor (batch)
            this._sendSpans([]);
        }
    }
    /**
     * Transforms an OpenTelemetry span to a Zipkin span.
     */
    _toZipkinSpan(span) {
        return transform_1.toZipkinSpan(span, this._serviceName, this._statusCodeTagName, this._statusDescriptionTagName);
    }
    /**
     * Transform spans and sends to Zipkin service.
     */
    _sendSpans(spans, done) {
        const zipkinSpans = spans.map(span => this._toZipkinSpan(span));
        return this._send(zipkinSpans, (result) => {
            if (done) {
                return done(result);
            }
        });
    }
    /**
     * Send spans to the remote Zipkin service.
     */
    _send(zipkinSpans, done) {
        if (zipkinSpans.length === 0) {
            this._logger.debug('Zipkin send with empty spans');
            return done(base_1.ExportResult.SUCCESS);
        }
        const { request } = this._reqOpts.protocol === 'http:' ? http : https;
        const req = request(this._reqOpts, (res) => {
            let rawData = '';
            res.on('data', chunk => {
                rawData += chunk;
            });
            res.on('end', () => {
                const statusCode = res.statusCode || 0;
                this._logger.debug('Zipkin response status code: %d, body: %s', statusCode, rawData);
                // Consider 2xx and 3xx as success.
                if (statusCode < 400) {
                    return done(base_1.ExportResult.SUCCESS);
                    // Consider 4xx as failed non-retriable.
                }
                else if (statusCode < 500) {
                    return done(base_1.ExportResult.FAILED_NOT_RETRYABLE);
                    // Consider 5xx as failed retriable.
                }
                else {
                    return done(base_1.ExportResult.FAILED_RETRYABLE);
                }
            });
        });
        req.on('error', (err) => {
            this._logger.error('Zipkin request error', err);
            return done(base_1.ExportResult.FAILED_RETRYABLE);
        });
        // Issue request to remote service
        const payload = JSON.stringify(zipkinSpans);
        this._logger.debug('Zipkin request payload: %s', payload);
        req.write(payload, 'utf8');
        req.end();
    }
}
exports.ZipkinExporter = ZipkinExporter;
ZipkinExporter.DEFAULT_URL = 'http://localhost:9411/api/v2/spans';
//# sourceMappingURL=zipkin.js.map