/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as types from '@opentelemetry/types';
import { MeterConfig } from './types';
import { ReadableMetric, MetricExporter } from './export/types';
/**
 * Meter is an implementation of the {@link Meter} interface.
 */
export declare class Meter implements types.Meter {
    private readonly _logger;
    private readonly _metrics;
    private readonly _exporters;
    readonly labels: typeof Meter.labels;
    /**
     * Constructs a new Meter instance.
     */
    constructor(config?: MeterConfig);
    /**
     * Creates and returns a new {@link Measure}.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createMeasure(name: string, options?: types.MetricOptions): types.Metric<types.BoundMeasure>;
    /**
     * Creates a new counter metric. Generally, this kind of metric when the
     * value is a quantity, the sum is of primary interest, and the event count
     * and value distribution are not of primary interest.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createCounter(name: string, options?: types.MetricOptions): types.Metric<types.BoundCounter>;
    /**
     * Creates a new gauge metric. Generally, this kind of metric should be used
     * when the metric cannot be expressed as a sum or because the measurement
     * interval is arbitrary. Use this kind of metric when the measurement is not
     * a quantity, and the sum and event count are not of interest.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createGauge(name: string, options?: types.MetricOptions): types.Metric<types.BoundGauge>;
    /**
     * Gets a collection of Metrics to be exported.
     * @returns The list of metrics.
     */
    getMetrics(): ReadableMetric[];
    /**
     * Add an exporter to the list of registered exporters
     *
     * @param exporter {@Link MetricExporter} to add to the list of registered exporters
     */
    addExporter(exporter: MetricExporter): void;
    /**
     * Provide a pre-computed re-useable LabelSet by
     * converting the unordered labels into a canonicalized
     * set of lables with an unique identifier, useful for pre-aggregation.
     * @param labels user provided unordered Labels.
     */
    static labels(labels: types.Labels): types.LabelSet;
    /**
     * Send a single metric by name to all registered exporters
     */
    private _exportOneMetric;
    /**
     * Registers metric to register.
     * @param name The name of the metric.
     * @param metric The metric to register.
     */
    private _registerMetric;
    /**
     * Ensure a metric name conforms to the following rules:
     *
     * 1. They are non-empty strings
     *
     * 2. The first character must be non-numeric, non-space, non-punctuation
     *
     * 3. Subsequent characters must be belong to the alphanumeric characters, '_', '.', and '-'.
     *
     * Names are case insensitive
     *
     * @param name Name of metric to be created
     */
    private _isValidName;
}
