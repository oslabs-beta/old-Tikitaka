"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@opentelemetry/core");
const Metric_1 = require("./Metric");
const types_1 = require("./types");
const LabelSet_1 = require("./LabelSet");
const Utils_1 = require("./Utils");
const base_1 = require("@opentelemetry/base");
/**
 * Meter is an implementation of the {@link Meter} interface.
 */
class Meter {
    /**
     * Constructs a new Meter instance.
     */
    constructor(config = types_1.DEFAULT_CONFIG) {
        this._metrics = new Map();
        this._exporters = [];
        this.labels = Meter.labels;
        this._logger = config.logger || new core_1.ConsoleLogger(config.logLevel);
    }
    /**
     * Creates and returns a new {@link Measure}.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createMeasure(name, options) {
        if (!this._isValidName(name)) {
            this._logger.warn(`Invalid metric name ${name}. Defaulting to noop metric implementation.`);
            return core_1.NOOP_MEASURE_METRIC;
        }
        // @todo: implement this method
        throw new Error('not implemented yet');
    }
    /**
     * Creates a new counter metric. Generally, this kind of metric when the
     * value is a quantity, the sum is of primary interest, and the event count
     * and value distribution are not of primary interest.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createCounter(name, options) {
        if (!this._isValidName(name)) {
            this._logger.warn(`Invalid metric name ${name}. Defaulting to noop metric implementation.`);
            return core_1.NOOP_COUNTER_METRIC;
        }
        const opt = Object.assign(Object.assign({ 
            // Counters are defined as monotonic by default
            monotonic: true, logger: this._logger }, types_1.DEFAULT_METRIC_OPTIONS), options);
        const counter = new Metric_1.CounterMetric(name, opt, () => {
            this._exportOneMetric(name);
        });
        this._registerMetric(name, counter);
        return counter;
    }
    /**
     * Creates a new gauge metric. Generally, this kind of metric should be used
     * when the metric cannot be expressed as a sum or because the measurement
     * interval is arbitrary. Use this kind of metric when the measurement is not
     * a quantity, and the sum and event count are not of interest.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */
    createGauge(name, options) {
        if (!this._isValidName(name)) {
            this._logger.warn(`Invalid metric name ${name}. Defaulting to noop metric implementation.`);
            return core_1.NOOP_GAUGE_METRIC;
        }
        const opt = Object.assign(Object.assign({ 
            // Gauges are defined as non-monotonic by default
            monotonic: false, logger: this._logger }, types_1.DEFAULT_METRIC_OPTIONS), options);
        const gauge = new Metric_1.GaugeMetric(name, opt, () => {
            this._exportOneMetric(name);
        });
        this._registerMetric(name, gauge);
        return gauge;
    }
    /**
     * Gets a collection of Metrics to be exported.
     * @returns The list of metrics.
     */
    getMetrics() {
        return Array.from(this._metrics.values())
            .map(metric => metric.get())
            .filter(Utils_1.notNull);
    }
    /**
     * Add an exporter to the list of registered exporters
     *
     * @param exporter {@Link MetricExporter} to add to the list of registered exporters
     */
    addExporter(exporter) {
        this._exporters.push(exporter);
    }
    /**
     * Provide a pre-computed re-useable LabelSet by
     * converting the unordered labels into a canonicalized
     * set of lables with an unique identifier, useful for pre-aggregation.
     * @param labels user provided unordered Labels.
     */
    static labels(labels) {
        const keys = Object.keys(labels).sort();
        const identifier = keys.reduce((result, key) => {
            if (result.length > 2) {
                result += ',';
            }
            return (result += key + ':' + labels[key]);
        }, '|#');
        const sortedLabels = {};
        keys.forEach(key => {
            sortedLabels[key] = labels[key];
        });
        return new LabelSet_1.LabelSet(identifier, sortedLabels);
    }
    /**
     * Send a single metric by name to all registered exporters
     */
    _exportOneMetric(name) {
        const metric = this._metrics.get(name);
        if (!metric)
            return;
        const readableMetric = metric.get();
        if (!readableMetric)
            return;
        for (const exporter of this._exporters) {
            exporter.export([readableMetric], result => {
                if (result !== base_1.ExportResult.SUCCESS) {
                    this._logger.error(`Failed to export ${name}`);
                }
            });
        }
    }
    /**
     * Registers metric to register.
     * @param name The name of the metric.
     * @param metric The metric to register.
     */
    _registerMetric(name, metric) {
        if (this._metrics.has(name)) {
            this._logger.error(`A metric with the name ${name} has already been registered.`);
            return;
        }
        this._metrics.set(name, metric);
    }
    /**
     * Ensure a metric name conforms to the following rules:
     *
     * 1. They are non-empty strings
     *
     * 2. The first character must be non-numeric, non-space, non-punctuation
     *
     * 3. Subsequent characters must be belong to the alphanumeric characters, '_', '.', and '-'.
     *
     * Names are case insensitive
     *
     * @param name Name of metric to be created
     */
    _isValidName(name) {
        return Boolean(name.match(/^[a-z][a-z0-9_.\-]*$/i));
    }
}
exports.Meter = Meter;
//# sourceMappingURL=Meter.js.map