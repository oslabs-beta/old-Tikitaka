"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@opentelemetry/core");
const types_1 = require("@opentelemetry/types");
const http_1 = require("http");
const semver = require("semver");
const shimmer = require("shimmer");
const url = require("url");
const AttributeNames_1 = require("./enums/AttributeNames");
const Format_1 = require("./enums/Format");
const utils = require("./utils");
const version_1 = require("./version");
/**
 * Http instrumentation plugin for Opentelemetry
 */
class HttpPlugin extends core_1.BasePlugin {
    constructor(moduleName, version) {
        super(`@opentelemetry/plugin-${moduleName}`, version_1.VERSION);
        this.moduleName = moduleName;
        this.version = version;
        // For now component is equal to moduleName but it can change in the future.
        this.component = this.moduleName;
        this._spanNotEnded = new WeakSet();
        this._config = {};
    }
    /** Patches HTTP incoming and outcoming request functions. */
    patch() {
        this._logger.debug('applying patch to %s@%s', this.moduleName, this.version);
        shimmer.wrap(this._moduleExports, 'request', this._getPatchOutgoingRequestFunction());
        // In Node >=8, http.get calls a private request method, therefore we patch it
        // here too.
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.wrap(this._moduleExports, 'get', this._getPatchOutgoingGetFunction(http_1.request));
        }
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.wrap(this._moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction());
        }
        else {
            this._logger.error('Could not apply patch to %s.emit. Interface is not as expected.', this.moduleName);
        }
        return this._moduleExports;
    }
    /** Unpatches all HTTP patched function. */
    unpatch() {
        shimmer.unwrap(this._moduleExports, 'request');
        if (semver.satisfies(this.version, '>=8.0.0')) {
            shimmer.unwrap(this._moduleExports, 'get');
        }
        if (this._moduleExports &&
            this._moduleExports.Server &&
            this._moduleExports.Server.prototype) {
            shimmer.unwrap(this._moduleExports.Server.prototype, 'emit');
        }
    }
    /**
     * Creates spans for incoming requests, restoring spans' context if applied.
     */
    _getPatchIncomingRequestFunction() {
        return (original) => {
            return this._incomingRequestFunction(original);
        };
    }
    /**
     * Creates spans for outgoing requests, sending spans' context for distributed
     * tracing.
     */
    _getPatchOutgoingRequestFunction() {
        return (original) => {
            return this._outgoingRequestFunction(original);
        };
    }
    _getPatchOutgoingGetFunction(clientRequest) {
        return (original) => {
            // Re-implement http.get. This needs to be done (instead of using
            // getPatchOutgoingRequestFunction to patch it) because we need to
            // set the trace context header before the returned ClientRequest is
            // ended. The Node.js docs state that the only differences between
            // request and get are that (1) get defaults to the HTTP GET method and
            // (2) the returned request object is ended immediately. The former is
            // already true (at least in supported Node versions up to v10), so we
            // simply follow the latter. Ref:
            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback
            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/plugins/plugin-http.ts#L198
            return function outgoingGetRequest(options, ...args) {
                const req = clientRequest(options, ...args);
                req.end();
                return req;
            };
        };
    }
    /**
     * Injects span's context to header for distributed tracing and finishes the
     * span when the response is finished.
     * @param request The original request object.
     * @param options The arguments to the original function.
     * @param span representing the current operation
     */
    _getMakeRequestTraceFunction(request, options, span) {
        return () => {
            var _a;
            this._logger.debug('makeRequestTrace by injecting context into header');
            const hostname = options.hostname || ((_a = options.host) === null || _a === void 0 ? void 0 : _a.replace(/^(.*)(\:[0-9]{1,5})/, '$1')) ||
                'localhost';
            const attributes = utils.getOutgoingRequestAttributes(options, {
                component: this.component,
                hostname,
            });
            span.setAttributes(attributes);
            request.on('response', (response) => {
                const attributes = utils.getOutgoingRequestAttributesOnResponse(response, { hostname });
                span.setAttributes(attributes);
                this._tracer.bind(response);
                this._logger.debug('outgoingRequest on response()');
                response.on('end', () => {
                    this._logger.debug('outgoingRequest on end()');
                    let status;
                    if (response.aborted && !response.complete) {
                        status = { code: types_1.CanonicalCode.ABORTED };
                    }
                    else {
                        status = utils.parseResponseStatus(response.statusCode);
                    }
                    span.setStatus(status);
                    if (this._config.applyCustomAttributesOnSpan) {
                        this._safeExecute(span, () => this._config.applyCustomAttributesOnSpan(span, request, response), false);
                    }
                    this._closeHttpSpan(span);
                });
                response.on('error', (error) => {
                    utils.setSpanWithError(span, error, response);
                    this._closeHttpSpan(span);
                });
            });
            request.on('close', () => {
                if (!request.aborted) {
                    this._closeHttpSpan(span);
                }
            });
            request.on('error', (error) => {
                utils.setSpanWithError(span, error, request);
                this._closeHttpSpan(span);
            });
            this._logger.debug('makeRequestTrace return request');
            return request;
        };
    }
    _incomingRequestFunction(original) {
        const plugin = this;
        return function incomingRequest(event, ...args) {
            // Only traces request events
            if (event !== 'request') {
                return original.apply(this, [event, ...args]);
            }
            const request = args[0];
            const response = args[1];
            const pathname = request.url
                ? url.parse(request.url).pathname || '/'
                : '/';
            const method = request.method || 'GET';
            plugin._logger.debug('%s plugin incomingRequest', plugin.moduleName);
            if (utils.isIgnored(pathname, plugin._config.ignoreIncomingPaths, (e) => plugin._logger.error('caught ignoreIncomingPaths error: ', e))) {
                return original.apply(this, [event, ...args]);
            }
            const propagation = plugin._tracer.getHttpTextFormat();
            const headers = request.headers;
            const spanOptions = {
                kind: types_1.SpanKind.SERVER,
                attributes: utils.getIncomingRequestAttributes(request, {
                    component: plugin.component,
                    serverName: plugin._config.serverName,
                }),
            };
            const spanContext = propagation.extract(Format_1.Format.HTTP, headers);
            if (spanContext && core_1.isValid(spanContext)) {
                spanOptions.parent = spanContext;
            }
            const span = plugin._startHttpSpan(`${method} ${pathname}`, spanOptions);
            return plugin._tracer.withSpan(span, () => {
                plugin._tracer.bind(request);
                plugin._tracer.bind(response);
                // Wraps end (inspired by:
                // https://github.com/GoogleCloudPlatform/cloud-trace-nodejs/blob/master/src/plugins/plugin-connect.ts#L75)
                const originalEnd = response.end;
                response.end = function (...args) {
                    response.end = originalEnd;
                    // Cannot pass args of type ResponseEndArgs,
                    // tslint complains "Expected 1-2 arguments, but got 1 or more.", it does not make sense to me
                    const returned = plugin._safeExecute(span, 
                    // tslint:disable-next-line:no-any
                    () => response.end.apply(this, arguments), true);
                    const attributes = utils.getIncomingRequestAttributesOnResponse(response);
                    span
                        .setAttributes(attributes)
                        .setStatus(utils.parseResponseStatus(response.statusCode));
                    if (plugin._config.applyCustomAttributesOnSpan) {
                        plugin._safeExecute(span, () => plugin._config.applyCustomAttributesOnSpan(span, request, response), false);
                    }
                    plugin._closeHttpSpan(span);
                    return returned;
                };
                return plugin._safeExecute(span, () => original.apply(this, [event, ...args]), true);
            });
        };
    }
    _outgoingRequestFunction(original) {
        const plugin = this;
        return function outgoingRequest(options, ...args) {
            if (!utils.isValidOptionsType(options)) {
                return original.apply(this, [options, ...args]);
            }
            const extraOptions = typeof args[0] === 'object' &&
                (typeof options === 'string' || options instanceof url.URL)
                ? args.shift()
                : undefined;
            const { origin, pathname, method, optionsParsed } = utils.getRequestInfo(options, extraOptions);
            options = optionsParsed;
            if (utils.isOpenTelemetryRequest(options) ||
                utils.isIgnored(origin + pathname, plugin._config.ignoreOutgoingUrls, (e) => plugin._logger.error('caught ignoreOutgoingUrls error: ', e))) {
                return original.apply(this, [options, ...args]);
            }
            const currentSpan = plugin._tracer.getCurrentSpan();
            const operationName = `${method} ${pathname}`;
            const spanOptions = {
                kind: types_1.SpanKind.CLIENT,
                parent: currentSpan ? currentSpan : undefined,
            };
            const span = plugin._startHttpSpan(operationName, spanOptions);
            plugin._tracer
                .getHttpTextFormat()
                .inject(span.context(), Format_1.Format.HTTP, options.headers);
            const request = plugin._safeExecute(span, () => original.apply(this, [options, ...args]), true);
            plugin._logger.debug('%s plugin outgoingRequest', plugin.moduleName);
            plugin._tracer.bind(request);
            // Checks if this outgoing request is part of an operation by checking
            // if there is a current span, if so, we create a child span. In
            // case there is no active span, this means that the outgoing request is
            // the first operation, therefore we create a span and call withSpan method.
            if (!currentSpan) {
                plugin._logger.debug('outgoingRequest starting a span without context');
                return plugin._tracer.withSpan(span, plugin._getMakeRequestTraceFunction(request, options, span));
            }
            else {
                plugin._logger.debug('outgoingRequest starting a child span');
                return plugin._getMakeRequestTraceFunction(request, options, span)();
            }
        };
    }
    _startHttpSpan(name, options) {
        const span = this._tracer
            .startSpan(name, options)
            .setAttribute(AttributeNames_1.AttributeNames.COMPONENT, this.component);
        this._spanNotEnded.add(span);
        return span;
    }
    _closeHttpSpan(span) {
        if (!this._spanNotEnded.has(span)) {
            return;
        }
        span.end();
        this._spanNotEnded.delete(span);
    }
    _safeExecute(span, execute, rethrow) {
        try {
            return execute();
        }
        catch (error) {
            if (rethrow) {
                utils.setSpanWithError(span, error);
                this._closeHttpSpan(span);
                throw error;
            }
            this._logger.error('caught error ', error);
        }
    }
}
exports.HttpPlugin = HttpPlugin;
exports.plugin = new HttpPlugin('http', process.versions.node);
//# sourceMappingURL=http.js.map