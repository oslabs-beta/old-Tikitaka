"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const types = require("@opentelemetry/types");
const core_1 = require("@opentelemetry/core");
const types_1 = require("@opentelemetry/types");
const Span_1 = require("./Span");
const utility_1 = require("./utility");
const NoopSpanProcessor_1 = require("./NoopSpanProcessor");
const MultiSpanProcessor_1 = require("./MultiSpanProcessor");
const config_1 = require("./config");
/**
 * This class represents a basic tracer.
 */
class BasicTracer {
    /**
     * Constructs a new Tracer instance.
     */
    constructor(config = config_1.DEFAULT_CONFIG) {
        this._registeredSpanProcessor = [];
        this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();
        const localConfig = utility_1.mergeConfig(config);
        this._binaryFormat = localConfig.binaryFormat;
        this._defaultAttributes = localConfig.defaultAttributes;
        this._httpTextFormat = localConfig.httpTextFormat;
        this._sampler = localConfig.sampler;
        this._scopeManager = localConfig.scopeManager;
        this._traceParams = localConfig.traceParams;
        this.logger = config.logger || new core_1.ConsoleLogger(config.logLevel);
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    startSpan(name, options = {}) {
        const parentContext = this._getParentSpanContext(options.parent);
        // make sampling decision
        const samplingDecision = this._sampler.shouldSample(parentContext);
        const spanId = core_1.randomSpanId();
        let traceId;
        let traceState;
        if (!parentContext || !core_1.isValid(parentContext)) {
            // New root span.
            traceId = core_1.randomTraceId();
        }
        else {
            // New child span.
            traceId = parentContext.traceId;
            traceState = parentContext.traceState;
        }
        const traceFlags = samplingDecision
            ? types_1.TraceFlags.SAMPLED
            : types_1.TraceFlags.UNSAMPLED;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        const recordEvents = options.isRecording || false;
        if (!recordEvents && !samplingDecision) {
            this.logger.debug('Sampling is off, starting no recording span');
            return new core_1.NoRecordingSpan(spanContext);
        }
        const span = new Span_1.Span(this, name, spanContext, options.kind || types.SpanKind.INTERNAL, parentContext ? parentContext.spanId : undefined, options.links || [], options.startTime);
        // Set default attributes
        span.setAttributes(Object.assign({}, this._defaultAttributes, options.attributes));
        return span;
    }
    /**
     * Returns the current Span from the current context.
     *
     * If there is no Span associated with the current context, null is returned.
     */
    getCurrentSpan() {
        // Get the current Span from the context or null if none found.
        const current = this._scopeManager.active();
        if (current === null || current === undefined) {
            return;
        }
        else {
            return current;
        }
    }
    /**
     * Enters the scope of code where the given Span is in the current context.
     */
    withSpan(span, fn) {
        // Set given span to context.
        return this._scopeManager.with(span, fn);
    }
    /**
     * Bind a span (or the current one) to the target's scope
     */
    bind(target, span) {
        return this._scopeManager.bind(target, span);
    }
    /**
     * Returns the binary format interface which can serialize/deserialize Spans.
     */
    getBinaryFormat() {
        return this._binaryFormat;
    }
    /**
     * Returns the HTTP text format interface which can inject/extract Spans.
     */
    getHttpTextFormat() {
        return this._httpTextFormat;
    }
    /** Returns the active {@link TraceParams}. */
    getActiveTraceParams() {
        return this._traceParams;
    }
    /**
     * Adds a new {@link SpanProcessor} to this tracer.
     * @param spanProcessor the new SpanProcessor to be added.
     */
    addSpanProcessor(spanProcessor) {
        this._registeredSpanProcessor.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessor);
    }
    _getParentSpanContext(parent) {
        if (!parent)
            return undefined;
        // parent is a SpanContext
        if (parent.traceId) {
            return parent;
        }
        if (typeof parent.context === 'function') {
            return parent.context();
        }
        return undefined;
    }
}
exports.BasicTracer = BasicTracer;
//# sourceMappingURL=BasicTracer.js.map