"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@opentelemetry/types");
const core_1 = require("@opentelemetry/core");
const DEFAULT_BUFFER_SIZE = 100;
const DEFAULT_BUFFER_TIMEOUT_MS = 20000;
/**
 * Implementation of the {@link SpanProcessor} that batches spans exported by
 * the SDK then pushes them to the exporter pipeline.
 */
class BatchSpanProcessor {
    constructor(_exporter, config) {
        this._exporter = _exporter;
        this._finishedSpans = [];
        this._lastSpanFlush = Date.now();
        this._bufferSize =
            config && config.bufferSize ? config.bufferSize : DEFAULT_BUFFER_SIZE;
        this._bufferTimeout =
            config && config.bufferTimeout
                ? config.bufferTimeout
                : DEFAULT_BUFFER_TIMEOUT_MS;
        this._timer = setInterval(() => {
            if (this._shouldFlush()) {
                this._flush();
            }
        }, this._bufferTimeout);
        core_1.unrefTimer(this._timer);
    }
    // does nothing.
    onStart(span) { }
    onEnd(span) {
        if (span.context().traceFlags !== types_1.TraceFlags.SAMPLED)
            return;
        this._addToBuffer(span.toReadableSpan());
    }
    shutdown() {
        clearInterval(this._timer);
        this._exporter.shutdown();
    }
    /** Add a span in the buffer. */
    _addToBuffer(span) {
        this._finishedSpans.push(span);
        if (this._finishedSpans.length > this._bufferSize) {
            this._flush();
        }
    }
    _shouldFlush() {
        return (this._finishedSpans.length >= 0 &&
            Date.now() - this._lastSpanFlush >= this._bufferTimeout);
    }
    /** Send the span data list to exporter */
    _flush() {
        this._exporter.export(this._finishedSpans, () => { });
        this._finishedSpans = [];
        this._lastSpanFlush = Date.now();
    }
}
exports.BatchSpanProcessor = BatchSpanProcessor;
//# sourceMappingURL=BatchSpanProcessor.js.map